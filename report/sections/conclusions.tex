\documentclass{article}

\begin{document}
\subtitle{Conclusion & Analysis}

\author{Aditya Saligrama and Andrew Shen}

\maketitle

Rust seeks to provide safe code at compile time at the expense of ease of use while on the otherhand, Golang seeks to provide ease of use at the expense of somewhat unsafe code. 
\newline
Rust provides helpful compiler features to aid the programmer such as the ability to detect data races, dangerous accesses to mutability and reference of an object, and other suggestions that would otherwise cause the program to break down at runtime. Due to its extensive number of compiler features, this generally results in far more time spent debugging errors and warnings proposed by the compiler. Additionally, the extra features also cause to code to be generally more dense creating more difficult to read code. However, the extensive checking done by the compiler gives the programmer the liberty of not needing to use excessive print statements to debug incorrect code as it will be likely detected by the rust compiler.
\newline
On the otherhand, Golang offers far more freedom over the code than Rust at the expense of possibly unsafe, dangerous code. The compiler is far less restrictive and will not stop the programmer writing incorrect code, making only few corrections. Golang code is easier to make it past compile time at the expense of more time used in the debugging stage during runtime. Programmers will likely need to use print statements or other mechanisms to detect incorrections in their code. However, the lack of restrictions on the code from the compiler helps to create generally less dense code that is easier to read in contrast to Rust code.
\newline
Rust and Golang have two major trade offs in terms of usability, the safety that the language provides internally versus the ease of use and simplicity that the languages offers externally.
\newline
Rustâ€™s compiler provides useful and powerful tools to aid the programmer in constructing and utilizing safe concurrency. The compiler adds an additional layer of safety by checking for data races between threads. In Golang, the compile will not warn you of such errors in the code, but there do exist tools that will aid the detection of races such as the race detector. However, the race detector functions by running the code and specifically watching for races to report back to the programmer, however there is a level of uncertainty that is generated through this method of testing. For example, the programmer must determine how long the race detector should be run before they can convince themselves there is in fact no race. Furthermore, the race detector does not point to the exact lines of error as the Rust compiler does which creates further difficulties in debugging and fixing the problem. However, Rust also has its own problems with concurrency. As a programmer begins to develop low level code, the compile can only do so much and can no longer offer suggestions to fix the the code. One example of this is how the Rust compiler does not produce an error after both a read and write lock is taken. The code is able to pass through compile time checks as nothing wrong is apparent, but when run during runtime the code crashes holding both the read and write lock can produce a deadlock which causes a thread to panic, an error produced by the operating system rather than the compiler.

\end{document}

